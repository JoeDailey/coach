"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lobby = void 0;
const collections_1 = require("../collections");
const data_1 = require("../data");
const language_1 = require("../language");
const Versus_1 = require("./Versus");
class Lobby {
    constructor(id, name, min, max, teams, players = new Set(), readies = new Set()) {
        this.id = id;
        this.name = name;
        this.min = min;
        this.max = max;
        this.teams = teams;
        this.players = players;
        this.readies = readies;
    }
    static async get(channel) {
        const lobby = await Lobby.load(channel.id);
        return lobby !== null && lobby !== void 0 ? lobby : await Lobby.create(channel.id, channel.name, 2);
    }
    static async load(id) {
        var _a, _b;
        const [name, min, max, teams, players, readies] = await data_1.redis.multi()
            .get(`${id}:name`)
            .get(`${id}:min`)
            .get(`${id}:max`)
            .lrange(`${id}:teams`, 0, -1)
            .smembers(`${id}:players`)
            .smembers(`${id}:readies`)
            .exec();
        if (name[0] != null || name[1] == null)
            return null;
        return new Lobby(id, name[1], parseInt(min[1]), max[1] == null ? null : parseInt(max[1]), teams[1].map((t) => parseInt(t)), new Set((_a = players[1]) !== null && _a !== void 0 ? _a : []), new Set((_b = readies[1]) !== null && _b !== void 0 ? _b : []));
    }
    static async create(id, name, min, max = null, teams = []) {
        const mutation = data_1.redis.multi()
            .set(`${id}:name`, name)
            .set(`${id}:min`, min);
        max != null
            ? mutation.set(`${id}:max`, max)
            : mutation.del(`${id}:max`);
        mutation.del(`${id}:teams`);
        if (max != null)
            mutation.rpush(`${id}:teams`, ...teams);
        await mutation.exec();
        return new Lobby(id, name, min, max, teams);
    }
    async addPlayers(...players) {
        const mutation = data_1.redis.multi();
        for (const player of players) {
            mutation.sadd(`${this.id}:players`, player.id);
            this.players.add(player.id);
        }
        await mutation.exec();
    }
    async readyPlayers(...players) {
        let destroy = async () => { };
        const mutation = data_1.redis.multi();
        for (const player of players) {
            mutation.sadd(`${this.id}:players`, player.id);
            this.players.add(player.id);
            if (!this.readies.has(player.id)) {
                mutation.sadd(`${this.id}:readies`, player.id);
                this.readies.add(player.id);
                destroy = async () => await this.destroyReadyCache();
            }
        }
        await Promise.all([
            mutation.exec(),
            destroy(),
        ]);
    }
    async removePlayers(...players) {
        let destroy = async () => { };
        const mutation = data_1.redis.multi();
        for (const player of players) {
            mutation.srem(`${this.id}:players`, player.id);
            this.players.delete(player.id);
            if (this.readies.has(player.id)) {
                mutation.srem(`${this.id}:readies`, player.id);
                this.readies.delete(player.id);
                destroy = async () => await this.destroyReadyCache();
            }
        }
        await Promise.all([
            mutation.exec(),
            destroy(),
        ]);
    }
    async unreadyPlayers(...players) {
        let destroy = async () => { };
        const mutation = data_1.redis.multi();
        for (const player of players) {
            mutation.sadd(`${this.id}:players`, player.id);
            this.players.add(player.id);
            if (this.readies.has(player.id)) {
                mutation.srem(`${this.id}:readies`, player.id);
                this.readies.delete(player.id);
                destroy = async () => await this.destroyReadyCache();
            }
        }
        await Promise.all([
            mutation.exec(),
            destroy(),
        ]);
    }
    async updateSettings(settings) {
        const mutation = data_1.redis.multi();
        if (settings.name != null) {
            mutation.set(`${this.id}:name`, settings.name);
            this.name = settings.name;
        }
        if (settings.min != null) {
            mutation.set(`${this.id}:min`, settings.min);
            this.min = settings.min;
        }
        if (settings.max != null) {
            mutation.set(`${this.id}:max`, settings.max);
            this.max = settings.max;
        }
        if (settings.teams != null) {
            mutation.del(`${this.id}:teams`);
            mutation.rpush(`${this.id}:teams`, ...settings.teams);
            this.teams = settings.teams;
        }
        await mutation.exec();
    }
    async destroyReadyCache() {
        const keys = await data_1.redis.keys(`${this.id}:rc:*`);
        const mutation = data_1.redis.multi();
        for (const key of keys) {
            mutation.del(key);
        }
        await mutation.exec();
    }
    isReady() {
        return this.readies.size >= this.min;
    }
    getTeams() {
        return this.teams;
    }
    getReadies() {
        return [...this.readies];
    }
    async getShuffle() {
        if (this.teams == null)
            throw (0, language_1.toUser)("Needs Team Setting");
        let [shuffles, index] = await this.getShufflesAndIndex();
        const match = shuffles[index];
        if (match == null) {
            await data_1.redis.set(`${this.id}:rc:shuffleIndex`, -1);
            throw (0, language_1.toUser)("All Matches Seen");
        }
        if (shuffles[++index] == null)
            index = -1;
        await data_1.redis.set(`${this.id}:rc:shuffleIndex`, index);
        return match;
    }
    async getShufflesAndIndex() {
        var _a;
        const result = await data_1.redis.multi()
            .get(`${this.id}:rc:shuffles`)
            .get(`${this.id}:rc:shuffleIndex`)
            .exec();
        let shuffles = result[0][1];
        let index = parseInt((_a = result[1][1]) !== null && _a !== void 0 ? _a : 0);
        if (shuffles == null) {
            shuffles = (0, collections_1.shuffle)(Versus_1.Versus.findAllMatches([...this.readies], this.teams));
            index = 0;
            await data_1.redis.multi()
                .set(`${this.id}:rc:shuffles`, JSON.stringify(shuffles))
                .set(`${this.id}:rc:shuffleIndex`, index)
                .exec();
            return [shuffles, index];
        }
        if (index == -1) {
            throw (0, language_1.toUser)("All Matches Seen");
        }
        shuffles = JSON.parse(shuffles);
        return [shuffles, index];
    }
    async getSplit(channel) {
        return await Promise.all([
            players(channel, [...this.readies]),
            players(channel, [...this.players].filter(u => !this.readies.has(u))),
        ]);
    }
    async print(channel, update = null, mention = false) {
        const [ready, others] = await this.getSplit(channel);
        const embed = {
            title: this.name,
            description: update,
            color: (this.isReady()) ? "GREEN" : "ORANGE",
            fields: [],
        };
        if (ready.length > 0) {
            let needed = '';
            if (this.isReady()) {
                if (this.max != null) {
                    needed = `, max: ${this.max}`;
                }
            }
            else {
                needed = `/${this.min}`;
            }
            embed.fields.push({
                name: `Players (${ready.length}${needed})`,
                value: ready.map(u => `• ${mention ? u : u.displayName}`).join("\n"),
                inline: false,
            });
        }
        if (others.length > 0) {
            embed.fields.push({
                name: `Not Ready (${others.length})`,
                value: others.map(u => `• ${u.displayName}`).join("\n"),
                inline: false,
            });
        }
        if (embed.description == null && ready.length === 0 && others.length === 0) {
            embed.description = "Join the lobby with `!join` or `!ready`";
        }
        embed.footer = {
            text: this.isReady()
                ? "Game is ready to start"
                : "More players can join",
        };
        return { embeds: [embed] };
    }
    async printSettings(channel) {
        const settings = [
            `\`name\` "${this.name}"`,
            `\`min\` ${this.min}`,
            `\`max\` ${this.max}`,
            `\`teams\` ${this.teams ? this.teams.join(',') : null}`,
        ];
        const embed = {
            title: this.name,
            color: "LUMINOUS_VIVID_PINK",
            fields: [
                {
                    name: "Settings",
                    value: settings.join("\n"),
                    inline: false,
                }
            ]
        };
        embed.footer = {
            text: "Use ?config to change settings",
        };
        return { embeds: [embed] };
    }
    async printMatch(channel, match) {
        const embed = {
            title: `Shuffles: ${this.name}`,
            color: "AQUA",
            fields: await Promise.all([...match].map(async (m, i) => ({
                name: `Team ${i + 1}`,
                value: (await players(channel, [...m]))
                    .map(p => `• ${p.displayName}`)
                    .join("\n"),
                inline: false,
            }))),
            footer: {
                text: "Use ?shuffle for a new matchup",
            }
        };
        return { embeds: [embed] };
    }
}
exports.Lobby = Lobby;
async function players(channel, ids) {
    return [...(await channel.guild.members.fetch({ user: ids })).values()];
}
//# sourceMappingURL=Lobby.js.map