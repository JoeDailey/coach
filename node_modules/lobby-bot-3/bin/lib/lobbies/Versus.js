"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Versus = void 0;
const ts_combinatorics_1 = require("ts-combinatorics");
const language_1 = require("../language");
const collections_1 = require("../collections");
class Versus {
    constructor(parent, team, pool, teamSizes, matches) {
        this.parent = parent;
        this.team = team;
        if (teamSizes.length === 0) {
            const match = this.finalizeMatch();
            if (match != null) {
                matches.add(match);
            }
            return;
        }
        const size = teamSizes[0];
        const nextTeamSizes = teamSizes.slice(1);
        for (const team of new ts_combinatorics_1.Combination(pool, size)) {
            const nextPool = pool.filter(p => !team.includes(p));
            new Versus(this, team, nextPool, nextTeamSizes, matches);
        }
    }
    static findAllMatches(readies, teams) {
        const sets = Versus.findAllMatcheSets(readies, teams);
        return sets.map(m => m.map(t => t.map(id => id)));
    }
    static findAllMatcheSets(readies, teams) {
        if (teams == null || teams.length === 0)
            throw (0, language_1.toUser)("Needs Team Setting");
        if (teams.length < 2 || teams.some(s => s < 1))
            throw (0, language_1.toUser)("Team Setting Invalid");
        if (readies.length < 2)
            throw (0, language_1.toUser)("Need More Ready Players");
        const matches = new collections_1.GSet();
        teams = distributeTeamsSizes(readies.length, teams);
        new Versus(null, [], readies, teams, matches);
        return matches;
    }
    finalizeMatch() {
        const versus = [this];
        let node = this;
        while ((node = node.parent) != null)
            if (node.team.length > 0)
                versus.push(node);
        versus.reverse();
        const teams = versus.map(v => new collections_1.FSet(v => v, ...v.team));
        const match = new collections_1.GSet(...teams);
        return match;
    }
}
exports.Versus = Versus;
function distributeTeamsSizes(numPlayers, teamSizes) {
    const needed = teamSizes.reduce((a, size) => a + size, 0);
    if (numPlayers >= needed)
        return teamSizes;
    const numTeams = teamSizes.length;
    const newTeams = Array(numTeams).fill(0);
    let index = 0;
    while (numPlayers > 0) {
        if (newTeams[index] < teamSizes[index]) {
            newTeams[index]++;
            numPlayers--;
        }
        index = (index + 1) % numTeams;
    }
    return newTeams;
}
//# sourceMappingURL=Versus.js.map