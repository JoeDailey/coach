"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
jest.mock('ioredis', () => require('ioredis-mock/jest'));
const discord_js_1 = require("../../mock/discord.js");
const Lobby_1 = require("../Lobby");
const client = discord_js_1.Mock.Client({ intents: [] });
let guildID = 0;
function guild() {
    const id = `guild${guildID++}`;
    return discord_js_1.Mock.Guild(client, { id, unavailable: false });
}
let channelID = 0;
function channel(g) {
    const id = `channel${channelID++}`;
    return discord_js_1.Mock.TextChannel(g !== null && g !== void 0 ? g : guild(), { id, type: 0, name: id });
}
let userID = 0;
function user() {
    const id = `user${userID++}`;
    return discord_js_1.Mock.User(client, { id, username: id });
}
function users(count) {
    return Array(count).fill(null).map(user);
}
async function lb() {
    const readies = users(4);
    const players = [...readies, ...users(4)];
    const lobby = await Lobby_1.Lobby.create(channel().id, 'foo', 9000, 9001, [1, 2, 3]);
    await lobby.addPlayers(...players);
    await lobby.readyPlayers(...readies);
    await lobby.destroyReadyCache();
    return lobby;
}
test("Persistance", async () => {
    const readies = users(4);
    const players = [...readies, ...users(4)];
    const cnl = channel();
    const lobby = await Lobby_1.Lobby.create(cnl.id, 'foo', 9000, 9001, [1, 2, 3]);
    await lobby.addPlayers(...players);
    await lobby.readyPlayers(...readies);
    await lobby.getShuffle();
    const reLobby = await Lobby_1.Lobby.get(cnl);
    expect(reLobby.name).toBe('foo');
    expect(reLobby.min).toBe(9000);
    expect(reLobby.max).toBe(9001);
    expect(reLobby.teams).toEqual([1, 2, 3]);
    expect([...reLobby.players]).toEqual(players.map(u => u.id));
    expect([...reLobby.readies]).toEqual(readies.map(u => u.id));
});
test("Shuffles increment", async () => {
    const lobby = await lb();
    (await expectShuffleIndex(lobby)).toBe(0);
    await lobby.getShuffle();
    (await expectShuffleIndex(lobby)).toBe(1);
});
test("ReadyCache untouched on new player", async () => {
    const lobby = await lb();
    await lobby.getShuffle();
    (await expectShuffleIndex(lobby)).toBe(1);
    const player = users(1)[0];
    await lobby.addPlayers(player);
    (await expectShuffleIndex(lobby)).toBe(1);
    await lobby.removePlayers(player);
    (await expectShuffleIndex(lobby)).toBe(1);
});
test("ReadyCache clear on new ready", async () => {
    const lobby = await lb();
    await lobby.getShuffle();
    (await expectShuffleIndex(lobby)).toBe(1);
    const player = users(1)[0];
    await lobby.readyPlayers(player);
    (await expectShuffleIndex(lobby)).toBe(0);
    await lobby.getShuffle();
    (await expectShuffleIndex(lobby)).toBe(1);
    await lobby.readyPlayers(player);
    (await expectShuffleIndex(lobby)).toBe(1);
});
test("ReadyCache clear on unready", async () => {
    const lobby = await lb();
    await lobby.getShuffle();
    (await expectShuffleIndex(lobby)).toBe(1);
    const player = users(1)[0];
    await lobby.unreadyPlayers(player);
    (await expectShuffleIndex(lobby)).toBe(1);
    await lobby.readyPlayers(player);
    (await expectShuffleIndex(lobby)).toBe(0);
    await lobby.getShuffle();
    (await expectShuffleIndex(lobby)).toBe(1);
    await lobby.unreadyPlayers(player);
    (await expectShuffleIndex(lobby)).toBe(0);
});
test("ReadyCache clear on leave", async () => {
    const lobby = await lb();
    await lobby.getShuffle();
    (await expectShuffleIndex(lobby)).toBe(1);
    const player = users(1)[0];
    await lobby.removePlayers(player);
    (await expectShuffleIndex(lobby)).toBe(1);
    await lobby.readyPlayers(player);
    (await expectShuffleIndex(lobby)).toBe(0);
    await lobby.getShuffle();
    (await expectShuffleIndex(lobby)).toBe(1);
    await lobby.removePlayers(player);
    (await expectShuffleIndex(lobby)).toBe(0);
});
async function expectShuffleIndex(lobby) {
    const [_, index] = await lobby.getShufflesAndIndex();
    return expect(index);
}
//# sourceMappingURL=LobbyTest.js.map