import { Combination } from "ts-combinatorics";
import { toUser } from "../language";
import { FSet, GSet } from "../collections";

export type ID = string;
export type Team = ID[];
export type Match = Team[];

export type TeamSet = FSet<ID>;
export type MatchSet = GSet<TeamSet>;

/**
 * Verses is a short-lived path-finder that starts with a
 * pool of players and a team list (e.g. `[4, 4]` is two
 * teams of four). It terminates when it runs out of players
 * or fulfills all teams. Each node in the path is a team
 * of players.
 *
 * Note that teams can have any number of players and matches
 * can have any number of teams. The team sizes do not have to
 * be uniform. For example: `[1, 2, 3]` is valid.
 *
 * The final matches are appended to the `matches_ref` set.
 *
 * Sets are used to implicitly remove duplicates. There is
 * wasted work in doing this, but it solves the match finding
 * problem generally, and it is easier to read.
 */
export class Versus {

  public static findAllMatches(
    readies: Array<string>,
    teams: number[],
  ): Array<Match> {
    const sets = Versus.findAllMatcheSets(readies, teams);
    return sets.map(m => m.map(t => t.map(id => id)));
  }

  private static findAllMatcheSets(
    readies: Array<string>,
    teams: number[],
  ): GSet<MatchSet> {
    if (teams == null || teams.length === 0)
      throw toUser("Needs Team Setting");

    if (teams.length < 2 || teams.some(s => s < 1))
      throw toUser("Team Setting Invalid");

    if (readies.length < 2)
      throw toUser("Need More Ready Players");

    const matches = new GSet<MatchSet>();
    teams = distributeTeamsSizes(readies.length, teams);
    new Versus(null, [], readies, teams, matches);
    return matches;
  }

  private constructor(
    private parent: Versus | null,
    private team: Array<ID>,
    pool: Array<ID>,
    teamSizes: Array<number>,
    matches: GSet<MatchSet>,
  ) {
    if (teamSizes.length === 0) {
      const match = this.finalizeMatch(); 
      if (match != null) {
        matches.add(match);
      }
      return;
    }
    
    const size = teamSizes[0]; 
    const nextTeamSizes = teamSizes.slice(1);
    for (const team of new Combination(pool, size)) {
      const nextPool = pool.filter(p => !team.includes(p));
      new Versus(this, team, nextPool, nextTeamSizes, matches);
    }
  }

  private finalizeMatch(): MatchSet {
    const versus: Array<Versus> = [this];
    let node: Versus = this;
    while ((node = node.parent) != null)
      if (node.team.length > 0)
        versus.push(node);

    versus.reverse();
    const teams = versus.map(v => new FSet(v => v, ...v.team));
    const match = new GSet(...teams);
    return match;
  }
}

function distributeTeamsSizes(numPlayers: number, teamSizes: Array<number>): Array<number> {
  const needed = teamSizes.reduce((a, size) => a + size, 0);
  if (numPlayers >= needed)
    return teamSizes;

  const numTeams = teamSizes.length;
  const newTeams = Array(numTeams).fill(0);

  let index = 0
  while (numPlayers > 0) {
    if (newTeams[index] < teamSizes[index]) {
      newTeams[index]++;
      numPlayers--;
    }

    index = (index + 1) % numTeams
  }
  return newTeams;
}
