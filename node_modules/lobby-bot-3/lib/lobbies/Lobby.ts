import { APIUser } from "discord-api-types/payloads/v9";
import { User, TextChannel, ThreadChannel, MessageEmbedOptions, GuildMember } from "discord.js";
import IORedis from "ioredis";
import { shuffle } from "../collections";
import { redis } from "../data";
import { toUser } from "../language";
import { Versus, Match } from "./Versus";

export type Channel = TextChannel | ThreadChannel;
export type Player = User | APIUser | GuildMember;

export class Lobby {
  private constructor(
    readonly id: string,
    private name: string,
    private min: number,
    private max: number | null,
    private teams: Array<number>,
    private players: Set<string> = new Set(),
    private readies: Set<string> = new Set(),
  ) {}

  public static async get(channel: Channel) {
    const lobby = await Lobby.load(channel.id)
    return lobby ?? await Lobby.create(
      channel.id,
      channel.name,
      2, // min
    );
  }

  private static async load(id: string): Promise<Lobby | null> {
    const [name, min, max, teams, players, readies] = await redis.multi()
      .get(`${id}:name`)
      .get(`${id}:min`)
      .get(`${id}:max`)
      .lrange(`${id}:teams`, 0, -1)
      .smembers(`${id}:players`)
      .smembers(`${id}:readies`)
      .exec();

    if (name[0] != null || name[1] == null)
      return null;

    return new Lobby(id,
      name[1],
      parseInt(min[1]),
      max[1] == null ? null : parseInt(max[1]),
      teams[1].map((t: string) => parseInt(t)),
      new Set(players[1] ?? []),
      new Set(readies[1] ?? []),
    );
  }

  public static async create(
    id: string,
    name: string,
    min: number,
    max: number | null = null,
    teams: number[] = [],
  ) {
    const mutation = redis.multi()
      .set(`${id}:name`, name)
      .set(`${id}:min`, min);
    
    max != null
      ? mutation.set(`${id}:max`, max)
      : mutation.del(`${id}:max`);

    mutation.del(`${id}:teams`)
    if (max != null)
      mutation.rpush(`${id}:teams`, ...teams);

    await mutation.exec();
    return new Lobby(id, name, min, max, teams);
  }

  public async addPlayers(...players: Array<Player> ) {
    const mutation = redis.multi();
    for (const player of players) {
      mutation.sadd(`${this.id}:players`, player.id);
      this.players.add(player.id);
    }
    await mutation.exec();
  }

  public async readyPlayers(...players: Array<Player> ) {
    let destroy = async () => {};

    const mutation = redis.multi();
    for (const player of players) {
      mutation.sadd(`${this.id}:players`, player.id);
      this.players.add(player.id);

      if (!this.readies.has(player.id)) {
        mutation.sadd(`${this.id}:readies`, player.id);
        this.readies.add(player.id);
        destroy = async () => await this.destroyReadyCache();
      }
    }
    
    await Promise.all([
      mutation.exec(),
      destroy(),
    ]);
  }

  public async removePlayers(...players: Array<Player> ) {
    let destroy = async () => {};

    const mutation = redis.multi();
    for (const player of players) {
      mutation.srem(`${this.id}:players`, player.id);
      this.players.delete(player.id);

      if (this.readies.has(player.id)) {
        mutation.srem(`${this.id}:readies`, player.id);
        this.readies.delete(player.id);
        destroy = async () => await this.destroyReadyCache();
      }
    }
    
    await Promise.all([
      mutation.exec(),
      destroy(),
    ]);
  }

  public async unreadyPlayers(...players: Array<Player> ) {
    let destroy = async () => {};

    const mutation = redis.multi();
    for (const player of players) {
      mutation.sadd(`${this.id}:players`, player.id);
      this.players.add(player.id);

      if (this.readies.has(player.id)) {
        mutation.srem(`${this.id}:readies`, player.id);
        this.readies.delete(player.id);
        destroy = async () => await this.destroyReadyCache();
      }
    }
    
    await Promise.all([
      mutation.exec(),
      destroy(),
    ]);
  }

  public async updateSettings(settings: {
    name?: string,
    min?: number,
    max?: number,
    teams?: Array<number>,
  }) {
    const mutation = redis.multi();

    if (settings.name != null) {
      mutation.set(`${this.id}:name`, settings.name);
      this.name = settings.name;
    }

    if (settings.min != null) {
      mutation.set(`${this.id}:min`, settings.min)
      this.min = settings.min;
    }

    if (settings.max != null) {
      mutation.set(`${this.id}:max`, settings.max)
      this.max = settings.max;
    }

    if (settings.teams != null) {
      mutation.del(`${this.id}:teams`);
      mutation.rpush(`${this.id}:teams`, ...settings.teams);
      this.teams = settings.teams;
    }

    await mutation.exec();
  }


  private async destroyReadyCache() {
    const keys = await redis.keys(`${this.id}:rc:*`);
    const mutation = redis.multi();
    for (const key of keys) {
      mutation.del(key);
    }
    await mutation.exec();
  }

  public isReady(): boolean {
    return this.readies.size >= this.min;
  }

  public getTeams(): number[] {
    return this.teams;
  }

  public getReadies(): string[] {
    return [...this.readies];
  }

  public async getShuffle(): Promise<Match> {
    if (this.teams == null)
      throw toUser("Needs Team Setting");

    let [shuffles, index] = await this.getShufflesAndIndex();
    const match = shuffles[index];
    if (match == null) {
      await redis.set(`${this.id}:rc:shuffleIndex`, -1)
      throw toUser("All Matches Seen");
    }

    if (shuffles[++index] == null)
      index = -1;
    
    await redis.set(`${this.id}:rc:shuffleIndex`, index)
    return match;
  }

  public async getShufflesAndIndex(): Promise<[Array<Match>, number]> {
    const result = await redis.multi()
      .get(`${this.id}:rc:shuffles`)
      .get(`${this.id}:rc:shuffleIndex`)
      .exec();

    let shuffles = result[0][1];
    let index = parseInt(result[1][1] ?? 0);

    if (shuffles == null) {
      shuffles = shuffle(Versus.findAllMatches([...this.readies], this.teams));
      index = 0;
      await redis.multi()
        .set(`${this.id}:rc:shuffles`, JSON.stringify(shuffles))
        .set(`${this.id}:rc:shuffleIndex`, index)
        .exec();
      return [shuffles, index];
    }

    if (index == -1) {
      throw toUser("All Matches Seen");
    }

    shuffles = JSON.parse(shuffles) as Array<Match>;
    return [shuffles, index];
  }

  private async getSplit(channel: Channel): Promise<[GuildMember[], GuildMember[]]> {
    return await Promise.all([
      players(channel, [...this.readies]),
      players(channel, [...this.players].filter(u => !this.readies.has(u))),
    ]);
  }

  public async print(
    channel: Channel,
    update: string | null = null,
    mention: boolean = false,
  ) {
    const [ready, others] = await this.getSplit(channel);
    const embed: MessageEmbedOptions = {
      title: this.name,
      description: update,
      color: (this.isReady()) ? "GREEN" : "ORANGE",
      fields: [],
    };

    if (ready.length > 0) {
      let needed = '';
      if (this.isReady()) {
        if (this.max != null) {
          needed = `, max: ${this.max}`;
        }
      } else {
        needed = `/${this.min}`;
      }
      embed.fields.push({
        name: `Players (${ready.length}${needed})`,
        value: ready.map(u => `• ${mention ? u : u.displayName}`).join("\n"),
        inline: false,
      });
    }

    if (others.length > 0) {
      embed.fields.push({
        name: `Not Ready (${others.length})`,
        value: others.map(u => `• ${u.displayName}`).join("\n"),
        inline: false,
      });
    }

    if (embed.description == null && ready.length === 0 && others.length === 0) {
      embed.description = "Join the lobby with `!join` or `!ready`";
    }

    embed.footer = {
      text: this.isReady()
        ? "Game is ready to start"
        : "More players can join",
    };

    return {embeds: [embed]};
  }

  public async printSettings(channel: Channel) {
    const settings = [
      `\`name\` "${this.name}"`,
      `\`min\` ${this.min}`,
      `\`max\` ${this.max}`,
      `\`teams\` ${this.teams ? this.teams.join(',') : null}`,
    ]
    const embed: MessageEmbedOptions = {
      title: this.name,
      color: "LUMINOUS_VIVID_PINK",
      fields: [
        {
          name: "Settings",
          value: settings.join("\n"),
          inline: false,
        }
      ]
    };

    embed.footer = {
      text: "Use ?config to change settings",
    };

    return {embeds: [embed]};    
  }

  public async printMatch(channel: Channel, match: Match) {
    const embed: MessageEmbedOptions = {
      title: `Shuffles: ${this.name}`,
      color: "AQUA",
      fields: await Promise.all([...match].map(async (m, i) => ({
        name: `Team ${i + 1}`,
        value: (await players(channel, [...m]))
          .map(p => `• ${p.displayName}`)
          .join("\n"),
        inline: false,
      }))),
      footer: {
        text: "Use ?shuffle for a new matchup",
      }
    };

    return {embeds: [embed]};    
  }

}

async function players(channel: Channel, ids: string[]): Promise<GuildMember[]> {
  return [...(await channel.guild.members.fetch({user: ids})).values()];
}
